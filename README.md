# Neo4 TS

Hello my name is Carlos aka Kingskull619, [Neo4TS](https://github.com/kingskull619/Neo4Ts) is a beta project made by me, as a necesity from various projects I'm working on.
Is a in progress project, feel free to fork and help if you want.

Neo4TS is a Neo4J Wrapper Object modeling tool designed to work in an asynchronous environment. You can use it instead of writting queries.
Fully support Neo4J 3.0^ and 4.0^.

## Installation

First install Node.js Then:

```bash
npm install neo4ts
```

## Importing

```js
import { Neo4TS } from 'neo4ts'
```

## Overview

### Connecting

First we need to define our connection parameters. We have to import ConfigurationManager to set our configuration to connect to the DB.

```js
import { ConfigurationManagers } from "neo4ts";

ConfigurationManagers.setConfiguration({
  databaseUrl: 'bolt://mygraphdb:7687',
  databaseUser: 'user',
  databasePassword: 'mypass',
});
```

Once set the configuration Neo4TS will manage the driver connection for you, if you want to check the connection you can use:

```js
import { ConfigurationManagers } from "neo4ts";

ConfigurationManagers.isDriverOpen();
```

And you can close the connection if you prefer:

```js
import { ConfigurationManagers } from "neo4ts";

ConfigurationManagers.closeDriver();
```

### Making queries

You can build a Cypher Query Action by importing ```neo4ts``` and use one of the cypher query building.

A Cypher Query Action is a virtual container for a [GraphAbstraction](#graphabstraction-object) that later can be translated into a valid cypher query with special capabilities or executed to a database

```js
import { Neo4TS } from 'neo4ts';

const dbAction = Neo4TS.findAll({
  person: {
   labels: ['Human', 'Person'] 
  }
});
```

Then you can execute it asyncronous by calling the execute method 

```js
import { Neo4TS } from 'neo4ts';

const dbAction = Neo4TS.findAll(...)
  .execute()
  .then(res => console.log(res));
```

You can also look for the query string by calling the getQuery or getPrettyQuery for a more readable response.

```js
import { Neo4TS } from 'neo4ts';

const dbAction = Neo4TS.findAll(...).getQuery();
```

This will return the query as:
```txt
MATCH (person :Human:Person) return person
```
## GraphAbstraction object
A graph abstraction is an JS Object which represnts a set of graph entities structured in the Database. There is two main abstractions:

* **Node**: called [GraphEntity](#graphentity)
* **Relationships**: called [GraphRelationship](#graphrelationship)

Both share most of the functionality with a tiny difference, _Relationships_ have two additional properties: ```from```|```source``` and ```to```|```target```.

You can create a ```GraphAbstraction``` by importing and using:

```ts
import { Neo4TSTypes } from 'neo4ts';

const graphAbstraction: Neo4TSTypes.GraphAbstraction = {};
```
A graph abstraction type is defined as: ```Record<string, GraphEntity | GraphRelationship>```. Which implies an JS Object containing N number of properties being GraphEntities or GraphRelationships.

For example:

```ts
const graphAbstraction: Neo4TSTypes.GraphAbstraction = {
  node: {}
};
```

The ```node``` name will be used by Neo4TS as an alias for the queries generated by the lirabry. The object as mentioned before is a ```GraphEntity | GraphRelationship``` that will be used by the library.

### GraphEntity
A Graph entity is an abstract representations of a [Node in Neo4J DB](https://neo4j.com/docs/getting-started/current/graphdb-concepts/#graphdb-nodes). Is defined as a JS Object containing multiple properties.

#### Labels

```ts
label?: string | string[];
labels?: string | string[];
```

As in Neo4J Nodes can be added and grouped by a set of [labels](https://neo4j.com/docs/getting-started/current/graphdb-concepts/#graphdb-labels), you can add labels to your ```GraphEntity``` by using one of the following properties:

* label
* labels

Both single and plural representation are valid to represent a label ino a ```GraphEntity```.

```ts
const example1: GraphEntity = {
  label: 'MyLabel'
};

const example2: GraphEntity = {
  labels: 'MyLabel'
}
```

Both ```example1``` and ```example2``` have the same effect for representating an Entity with a label.

You can also define a collection of labels, by passing an array instead of an string.

```ts
const example1: GraphEntity = {
  label: ['MyLabel', 'MySecondLabel']
};

const example2: GraphEntity = {
  labels: ['MyLabel', 'MySecondLabel']
}
```

#### Id
```ts
 id?: string | number;
```
You can set the id of your Entity by using the id property, this is a reference to the native [ID key of Neo4J](https://neo4j.com/docs/cypher-manual/4.3/functions/scalar/#functions-id)

```ts
const entity: GraphEntity = {
  id: 1
};
```

#### isReturnable
```ts
isReturnable?: boolean
```

Is returnable will define if the entitie will be returned once the action is executed in the database.
By default all entities have ```isReturnable``` set to ```TRUE```.

#### isOptional
```ts
isOptional?: boolean
```
When Neo4TS is building the match pattern to use in cypher it will look for the ```isOptional``` propertie to decide between MATCH or OPTIONAL MATCH.
By default all entities have ```isOptional``` set to ```FALSE```.

#### Properties
```ts
properties?: Record<string, GraphProperty>
```
```ts
type GraphProperty =
    | string
    | number
    | boolean
    | Date
    | string[]
    | number[]
    | boolean[]
    | GraphPropertyDefinition
    | Record<string, any>;
```
You can set properties, to you abstraction, this will be usefull for filtering your data, or to create and update data of a certain entitiy, look for more on actions.

a property is a JS Object where the property name will be used as the database property name.

```ts
const entity: GraphEntity = {
  properties: {
    name: 'my name'
  }
};
```

##### Primitive values
Neo4TS support many primitive values, and will infer the correct type to save it to the Neo4J Database.

* string
* number
* boolean
* Date
* string[ ]
* number[ ]
* boolean[ ]

##### Object values
As you can see on the type definitionfor ```GraphProperty``` it also support objects by ```Record<string, any>```.

**Neo4TS will convert them into JSON string to use them either for saving or filtering**

##### GraphPropertyDefinition
You can define more complex features from properties using an object called ```GraphPropertyDefinition```.
A graph property definition is an special JS Object to define a property value and extra capabilities.

All ```GraphPropertyDefinition``` objects should contain ```type``` and ```value``` properties, the rest of them are optional extra features.

```ts
const entity: GraphEntity = {
  properties: {
    name: {
      type: 'string',
      value: 'my name'
    }
  }
};
```

###### Value and Type
A ```GraphPropertyDefinition``` should define a value and type that will be used on this property. Supported types are:

```ts
| 'integer'
| 'number'
| 'float'
| 'boolean'
| 'string'
| 'date'
| 'time'
| 'datetime'
| 'array'
```

This is usefull because you can set a different primitive type in the value property, and Neo4TS will parse to the correct type to use it into the Database.

```ts
const entity: GraphEntity = {
  properties: {
    name: {
      type: 'string',
      value: 100
    }
  }
};
```

In the previous expample value is a number but type property is defined as string, so when is used to filter or setting data into the database it will be transformed to a string value.

This is also usefull to work with Dates, **as default Neo4TS will threat all Dates as DateTime types for Neo4J**, but by using a ```GraphPropertyDefinition``` you can switch this behaviour to use: ```time```, ```date``` or ```datetime```.

```ts
const entity: GraphEntity = {
  properties: {
    timeOfDelivery: {
      type: 'time',
      value: new Date()
    }
  }
};
```

###### Filtering capabilities
In some cases you want to use the ```GraphPropertyDefinition``` to filter your data. Neo4TS provide some capabilities to filter them.


###### Condition
As default Neo4TS will use the equal condition to compare when using properties as filters. If you want to change this behaviour you can use the Condition property to alter it.

The conditions supported are:

```ts
//following strings are threated as equality
| 'equal'
| '='
//following strings are threated as different
| 'different'
| '<>'
| '!='
//following strings are threated as contain, case insensitive
| 'contains'
//following strings are threated as not contain, case insensitive
| 'not contains'
| '!contains'
//following strings are threated as start with, case insensitive
| 'starts'
| 'starts with'
//following strings are threated as ends with, case insensitive
| 'ends'
| 'ends with'
//following strings are threated as greater
| 'greater'
| '>'
//following strings are threated as greater or equal
| 'greaterequal'
| 'greater equal'
| 'equalgreater'
| 'equal greater'
| '>='
//following strings are threated as lower
| 'lower'
| '<'
//following strings are threated as lower or equal
| 'lowerequal'
| 'lower equal'
| 'equal lower'
| 'equal lower'
| '<='
//following strings are threated as in array (provide an array as value)
| 'in'
//following strings are threated as if value is in property array (provide a primitive value)
| '!in'
| 'reversein'
| 'reverse in';
```
For example if we want to filter data for all persons with age of 15 or greater:

```ts
const person: GraphEntity = {
  properties: {
    age: {
      type: 'number',
      value: 15,
      condition: '>='
    }
  }
};
```

###### Operator
Neo4TS will use AND as the default operator, use the operator property, filters will respect the properties and entities order for chaining filters.

Operators values supported:
```ts
| 'and'
| 'or'
| 'xor'
| 'not'
```

For example if we want to filter data for all persons with age of 15 or Mexican nationality:

```ts
const person: GraphEntity = {
  properties: {
    age: {
      type: 'number',
      value: 15,
      condition: '>='
    },
    nationality: {
      type: 'string',
      value: 'mexican',
      condition: 'contains',
      operator: 'or'
    }
  }
};
```

### GraphRelationship
Relationshiips share all functionalities from [GraphEntity](#graphentity), in fact it's an extension of the same type.
The difference is that relationships will have a ```source``` and ```target``` properties to identify it as a relationship.

Both source and target are ```string``` properties, this string is the alias identifier of an existing [GraphEntity](#graphentity) inside a [GraphAbstraction](#graphabstraction-object)

```ts
const abstraction: GraphAbstraction = {
  nodeSource:   { label: 'person' }
  nodeTarget:   { label: 'dog' },
  relationship: { label: 'HAS', from: 'nodeSource', to: 'nodeTarget' }, // <==
};
```

#### Source
Source can be defined by one of the following properties:

* from
* source

```ts
const abstraction: GraphAbstraction = {
  nodeSource:   { label: 'person' }
  nodeTarget:   { label: 'dog' },
  relationshipEX1: { label: 'HAS', from: 'nodeSource', to: 'nodeTarget' }, // <==
  relationshipEX2: { label: 'HAS', source: 'nodeSource', to: 'nodeTarget' }, // <==
};
```
In the previous example both ```relationshipEX1``` and ```relationshipEX2``` have the same effect.

#### Target
Target can be defined by one of the following properties:

* to
* target

```ts
const abstraction: GraphAbstraction = {
  nodeSource:   { label: 'person' }
  nodeTarget:   { label: 'dog' },
  relationshipEX1: { label: 'HAS', from: 'nodeSource', to: 'nodeTarget' }, // <==
  relationshipEX2: { label: 'HAS', from: 'nodeSource', target: 'nodeTarget' }, // <==
};
```
In the previous example both ```relationshipEX1``` and ```relationshipEX2``` have the same effect.